# Data Types 

In every programming language, data is stored in different ways. Writing a program that manipulates data requires understanding all of the choices. That is why we must be concerned with the different **types** of data in our `R` and `Python` programs. Different types are suitable for different purposes.

There are similarities between `Python`'s and `R`'s type systems. However, there are may  differences as well. Be prepared for these differences. There are many more of them in this chapter than there were in the previous chapter!

If you're ever unsure what type a variable has, use `type()` (in `Python`) or `typeof()` (in `R`) to query it. 

TODO Test [@R-bookdown]


## Integers, Strings and Floating Point Numbers

Storing an individual piece of information is simple in both languages. However, while `Python` has scalar types, `R`'s situation is more complicated.

### In `Python`

In `Python`, the simplest types are `str` (short for string), `int` (short for integer), `float` (short for floating point) and `bool` (short for Boolean). 

```{python}
print(type('a'))
print(type(1))
print(type(1.3))
```

Strings are useful for processing text data such as names of people/places/things and messages (e.g. texts, tweets and emails). If you are dealing with numbers, you need floating points if you have a number that might have a fractional part after its decimal; otherwise you'll need an integer. Booleans are useful for situations where you need to record whether something is true or false. They are also important to understand for control-flow (TODO which section).

We will write much more complicated programs than the one below, so we will need to save different values as variables. This was mentioned in the previous chapter. We create them by using the assignment operator `=`. The name of the variable goes on the left of the assignment operator.

```{Python}
# in python
my_name = 'Charlie'
print('Hello! My name is ', my_name, '.', sep = '')
```

### In `R`

In `R`, the names of these simple types are a little different. They are `logical` (instead of `bool`), `integer` (instead of `int`), `double` (instead of `float`), `complex`, and `character` (instead of `str`). There is also `complex` and `raw`, but we will use these less often in this textbook.

Additionally, `R` uses the same type to store many elements of the same type. It does not have any scalar type. This is very different than `Python`. `Python` has base types of individual elements, and it uses a separate types as containers for many elements. In `R`, if you are looking at single number/string, it's actually a length $1$ `vector`. More information about `vector`s in TODO.

TODO constants versus literals?

https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Vector-objects


In `R`, there are no scalar types like this! If we wanted to make a "string", we would need to make a length $1$ character `vector`. 

```{r}
print(typeof('a'))
print(typeof(1))
print(typeof(1.3))
```



## `R` vectors, matrices and arrays versus `numpy` arrays 

This section is for describing the data types that let us store collections of elements that all **share the same type**. Data is very commonly stored in this fashion, so this section is quite important. Once we have one of these objects in a program, we will be interested in learning how to extract different subsets of elements, and how vectorization works

### In `R`

I mentioned earlier that `R` does not have scalar types--it just has vectors. So whether I wanted to store one number, or many numbers, I would be using a `vector`. 

.


Recycling
Filtering The extraction of subsets of vectors
Vectorization
`c`
mention the word "tensor"
Mention `NULL` versus `NA` versus `None` versus `numpy.nan`

## `R` lists versus `Python` lists, tuples and `dict`s and `set`s

When you need to store elements in a container, but you can't guarantee that these elements all have the same type, you need a `list`. Both `R` and `Python` have lists. 



## `R` data frames versus `Pandas` data frames

## `R` factors and tables versus ?

## Classes in `R` and `Python`

## Exercises

All answers to questions related to `R` should be written in a file named `data_types_exercises.R`. All answers to questions related to `Python` should be written in a file named `data_types_exercises.py`.


1. Which `Python` type is appropriate for each piece of data?

  a. TODO
  b. TODO
  
  
2. In `R`, say you have a vector of prices of some financial asset:

```{r}
prices <- c(100.10, 95.98, 100.01, 99.87)
```

a.
Convert this vector into a vector of *log returns*. Call the variable `log_returns`. If $p_t$ is the price at time $t$, the log return ending at time $t$ is 
$$ r_t = \log \left( \frac{p_t}{p_{t-1}} \right) = \log p_t - \log p_{t-1}$$

b.
Do the same for *arithmetic returns*. These are regular percent changes if you scale by $100$. Call the variable `arith_returns`. The mathematical formula you need is

$$ a_t = \left( \frac{p_t - p_{t-1} }{p_{t-1}} \right) \times 100 $$

3. Assume we are interested in the probability that a normal random variable with mean $5$ and standard deviation $6$ is greater than $6$.

a. Evaluate this probability exactly in `R` and assign it to the variable `exactExceedanceProb` 

b. Evaluate this probability exactly in `Python` and assign it to the variable `exact_exceedance_prob`

c. In `R`, use the *Monte Carlo* (TODO cite) method to estimate the probability. Assign it to the variable `approxExceedanceProb`

d. In `Python`, use the *Monte Carlo* (TODO cite) method to estimate the probability. Assign it to the variable `approx_exceedance_prob`


4. For a collection of random variables $X_1, \ldots, X_n$, a *covariance matrix* arranges all of the covariances between every possible pair of random variables:

$$
\begin{bmatrix}
\text{Cov}(X_1, X_1) & \text{Cov}(X_1, X_2) & \cdots & \text{Cov}(X_1, X_n) \\
\text{Cov}(X_2, X_1) & \text{Cov}(X_2, X_2) & \cdots & \text{Cov}(X_2, X_n) \\
\vdots & \vdots & \ddots & \vdots\\
\text{Cov}(X_n, X_1) & \text{Cov}(X_n, X_2) & \cdots & \text{Cov}(X_n, X_n) \\
\end{bmatrix}
$$
where 
$$\text{Cov}(X_i, X_j) = \mathbb{E}\left[(X_i - \mathbb{E}[X_i])((X_j - \mathbb{E}[X_j])\right]$$
 is the covariance between $X_i$ and $X_j$ resting in row $i$ and column $j$. 
 
 Using this definition, it is easy to show that $\text{Cov}(X_i, X_i) = \mathbb{E}\left[(X_i - \mathbb{E}[X_i])^2\right] = \text{Var}(X_i)$.

An **exchangeable** covariance matrix for a random vector is one that has all the same variances, and all the same covariances. In other words, it has two unique elements: the diagonal elements should be the same, and the off-diagonals should be the same. 

a. In `R`, generate $10$ $4 \times 4$ exchangeable covariance matrices, each with $2$ as the variance, and have the possible covariances take values in the collection $0,.01,.02, ..., .09.$  Store these $10$ covariance matrices in a three-dimensional array. The first index should be each matrix's row index, the second should be the column index of each matrix, and the third index should be the "layer" or "slice" indicating which of the $10$ matrices you have. Name this array `myCovMats`

b. Do the same thing in `Python`, but call the variable `my_cov_mats`

5. In `R`, read in the `cars.csv` data set using `read.table()` (more on IO in chapter TODO). Find the average `EngineSize`, `Cylinders`, `Horsepower`, `MPG_City`, `MPG_Highway`, `Weight`, `Wheelbase` and `Length` **for each type of vehicle** (i.e. `Hybrid` `Sedan` `Sports`, `SUV`, `Truck` and `Wagon`). Which of these averages is an `NA`? How many observations in that column are missing? 

6. In `Python` (TODO finish this question), read in the `cars.csv` data set using `read.table()` (more on IO in chapter TODO). Find the average `EngineSize`, `Cylinders`, `Horsepower`, `MPG_City`, `MPG_Highway`, `Weight`, `Wheelbase` and `Length` **for each type of vehicle** (i.e. `Hybrid` `Sedan` `Sports`, `SUV`, `Truck` and `Wagon`). Which of these averages is an `NA`? How many observations in that column are missing? 


6.  Here are two lists in `R`:

```{r}
l1 <- list(first="a", second=1)
l2 <- list(first=c(1,2,3), second = "statistics")
```



a. Make a new `list` that is these two lists above "squished together." It has to be length $4$, and each element is one of the elements of $l1$ and $l2$. Call this list `l3`.

b. Delete all the "tags" or "names" of these four elements.

c. Make a `vector` of all the unique single digit numbers in both of the lists. You should end up with the vector with elements `1`, `2`, and `3`.


7.  Here are two `dict`s in `Python`:

```{Python}
d1 = { "first" : "a", "second" : 1}
d2 = { "first" : [1,2,3], "second" : "statistics"}
```



a. Make a new `list` that is these two `dict`s above "squished together" (why can't it be another `dict`?) It has to be length $4$, and each value is one of the values of $d1$ and $d2$. Call this list `l3`.


8. How might you explain the difference between `Python` and `R`'s type systems? What do you know about the historical development of these languages that might assist your explanation?
