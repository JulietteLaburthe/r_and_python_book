--- 
title: 'An Introduction to R and Python For Data Analysis: A Side By Side Approach'
author: "Taylor R. Brown"
site: bookdown::bookdown_site
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
documentclass: krantz
lot: yes
lof: yes
fontsize: 12pt
monofont: "Source Code Pro"
monofontoptions: "Scale=0.7"
bibliography:
- book.bib
- packages.bib
biblio-style: apalike
link-citations: yes
github-repo: tbrown122387/r_and_python_book
---

# Welcome {-}

Placeholder


## A Sample Course {-}
## License(s) {-}

<!--chapter:end:index.Rmd-->


# Preface {-}

Placeholder


## About this book {-}
## Conventions {-}
## Installing the Required Software {-}
### Installing R (and RStudio) {-}
### Installing Python by Installing Anaconda {-} 

<!--chapter:end:preface.Rmd-->


# (PART) Introducing the Basics {-} 

Placeholder


## Hello World in R
## Hello World in Python
## Getting Help
### Reading Documentation
### Understanding File Paths

<!--chapter:end:01-intro.Rmd-->


# Basic Types

Placeholder


## Basic Types In Python
### Type Conversions in Python
## Basic Types In R
### Type Conversions in R
### R's Simplification
## Exercises
### R Questions
### Python Questions

<!--chapter:end:02-basic_types.Rmd-->


# R `vector`s versus Numpy `array`s and Pandas' `Series`

Placeholder


## Overview of R
## Overview of Python
## Vectorization in R
## Vectorization in Python
## Indexing Vectors in R
## Indexing Numpy arrays
## Indexing Pandas' Series
## Some Gotchas
### Shallow versus Deep Copies
### How R and Python Handle Missing Values
## Exercises
### R Questions
### Python Questions

<!--chapter:end:03-vectors_and_arrays.Rmd-->


# Numpy `ndarray`s Versus R's `matrix` and `array` Types

Placeholder


## Numpy `ndarray`s In Python
## The `matrix` and `array` classes in R
## Exercises
### R Questions
### Python Questions

<!--chapter:end:04-arrays_and_matrices.Rmd-->


# R's `list`s Versus Python's `list`s and `dict`s

Placeholder


## `list`s In R
## `list`s In Python
## Dictionaries In Python
## Exercises
### R Questions
### Python Questions

<!--chapter:end:05-lists_and_dictionaries.Rmd-->


# Functions

Placeholder


## Defining R Functions
## Defining Python Functions
## More Details On R's User-Defined Functions
## More details on Python's user-defined functions
## Function Scope in R
## Function Scope in Python
## Modifying a Function's Arguments
### Passing By Value In R
### Passing By Assignment In Python
## Accessing and Modifying Captured Variables
### Accessing Captured Variables in R
### Accessing Captured Variables in Python
### Modifying Captured Variables In R
### Modifying Captured Variables In Python

<!--chapter:end:06-functions.Rmd-->

# Categorical Data 

While statisticians may describe data as being either categorical or numerical, this classification is different than classifying data by its *type* in a program. So, strictly speaking, if you have categorical data, you are not obligated to use any particular type to represent it in your script. 

However, there are types that are specifically designed to be used with categorical data, and so they are especially advantageous to use if you end up with the opportunity. We describe a few of them here in this chapter.

## `factor`s in R

Categorical data in R is often stored in a [`factor`](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Factors) variable. `factor`s are more special than `vector`s of integers because

  * they have a `levels` attribute, which is comprised of all the possible values that each response could be; 
  * they may or may not be *ordered*, which will also control how they are used in mathematical functions;
  * they might have a `contrasts` attribute, which will control how they are used in statistical modeling functions.

Here is a first example. Say we asked three people what their favorite season was. The data might look something like this.

```{r, collapse = TRUE}
allSeasons <- c("autumn", "summer", "spring", "winter")
responses <- factor(c("autumn", "summer", "summer"), 
                    levels = allSeasons)
levels(responses)
is.factor(responses)
is.ordered(responses)
#contrasts(responses) # controls how factor is used in different  functions
```


`factor`s always have levels, which is the collection of all possible unique values each observation can take. 

::: {.rmd-caution}
You should be careful if you are not specifying them directly. What happens when you use the default option and replace the second assignment in the above code with `responses <- factor(c("autumn", "summer", "summer"))`? The documentation of `factor()` will tell you that, by default, `factor()` will just take the unique values found in the data. In this case, nobody prefers winter or spring, and so neither will show up in `levels(responses)`. This may or may not be what you want. 
:::

`factor`s can be ordered or unordered. Ordered `factor`s are for *ordinal* data. Ordinal data is a particular type of categorical data that recognizes the categories have a natural order (e.g. low/ medium/high and not red/green/blue).

As another example, say we asked ten people how much they liked statistical computing, and they could only respond "love it", "it's okay" or "hate it". The data might look something like this.

```{r, collapse = TRUE}
ordFeelOptions <- c("hate it", "it's okay", "love it")
responses <- factor(c("love it", "it's okay", "love it", 
                      "love it", "it's okay", "love it", 
                      "love it", "love it", "it's okay", 
                      "it's okay"), 
                    levels = ordFeelOptions,
                    ordered = TRUE)
levels(responses)
is.factor(responses)
is.ordered(responses)
# contrasts(responses)
```

::: {.rmd-caution}
When creating ordered factors with `factor()`, be mindful that the `levels=` argument is assumed to be ordered when you plug it into `factor()`. In the above example, if you specified `levels = c("love it", "it's okay", "hate it")`, then the factor would assume `love it < it's okay < hate it`, which may or may not be what you want.
:::

Last, `factor`s may or may not have a `contrast` attribute. You can get or set this with the `contrasts()` function. This will influence some of the functions you use on your data that estimate statistical models. 

I will not discuss specifics of contrasts in this text, but the overall motivation is important. In short, the primary reason for using `factor`s is that they are designed to allow control over *how* you model categorical data. To be more specific, changing attributes of a `factor` could control the paremeterization of a model you're estimating. If you're using a particular function for modeling with categorical data, you need to know how it treats factors. On the other hand, if you're writing a function that performs modeling of categorical data, you should know how to treat factors. 

Here are two examples that you might come across in your studies.

  1. Consider using `factor`s as inputs to a function that performs linear regression. With linear regression models, if you have categorical inputs, there are many choices for how to write down a model. In each model, the collection of parameters will mean different things. In R, you might pick the model by creating the `factor` in a specific way. 
  
  2. Suppose you are interested in estimating a classification model. In this case, the *dependent* variable is categorical, not the independent variable. With these types of models, choosing whether or not your `factor` is ordered is critical. These options would estimate completely different models, so choose wisely!

The mathematical details of these examples is outside of the scope of this text. If you have not learned about dummy variables in a regression course, or if you have not considered the difference between multinomial logistic regression and ordinal logistic regression, or if you have but you're just a little rusty, that is totally fine. I only mention these as examples for how the `factor` type can trigger special behavior. 

In addition to creating one with `factor()`, there are two other common ways that you can end up with `factors`:

  1. creating factors from numerical data, and
  2. when reading in an external data file, one of the columns is coerced to a `factor`.
  
Here is an example of (1). We can take non-categorical data, and `cut()` it into something categorical. 

```{r, collapse = TRUE}
stockReturns <- rnorm(10) # not categorical here
typeOfDay <- cut(stockReturns, breaks = c(-Inf, 0, Inf)) 
typeOfDay
levels(typeOfDay)
is.factor(typeOfDay)
is.ordered(typeOfDay)
```

Finally, be mindful of how different functions read in external data sets. When reading in an external file, if a particular function comes across a column that has characters in it, it will need to decide whether to store that column as a character vector, or as a `factor`. For example, `read.csv()` and `read.table()` have a `stringsAsFactors=` argument that you should be mindful of. 



## Categorical Data in Pandas

Pandas' `Series` were discussed earlier in sections \@ref(overview-of-python) and \@ref(vectorization-in-python). These were containers that forced every element to share the same `dtype`. When specifying `dtype="category"`, you get a type that is very similar to R's `factor`. The main differences are

1. instead of levels, the possible values each element can take are called `categories`, and
2. there is an `ordered` condition, which is exactly the same as `factor`s were in R. 


responses <- factor(c("autumn", "summer", "summer"), 
                    levels = c("autumn", "summer", "spring", "winter"))


Here is a quick example. 
```{python, collapse = TRUE}
import pandas as pd
responses = pd.Series(["autumn", "summer", "spring", "winter"], \
                      categories = ["autumn", "summer", "spring", "winter"] \
                      dtype="category")
responses
responses.cat.categories
responses.cat.ordered
```

[Categorical data can be handled with the pandas library](https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html), which takes a lot of inspiration from R. 


```{python, collapse = TRUE}
import pandas as pd
from pandas.api.types import CategoricalDtype

cat_type = CategoricalDtype(categories=["autumn", "summer", "spring", "winter"], 
                            ordered=False)
responses = pd.Series(["autumn", "summer", "summer"], 
                      dtype = cat_type)
responses
responses.cat.categories
responses.cat.ordered
```

The pandas library also provides a `pd.cut()` function, which can return either of these types, or even a regular Numpy array.

```{python, collapse = TRUE}
import numpy as np
stock_returns = np.random.normal(size=10) # not categorical here
type_of_day = pd.cut(stock_returns, [-np.inf, 0, np.inf], labels = ['bad day', 'good day']) 
type_of_day
type(type_of_day)
type_of_day = pd.Series(type_of_day)
type(type_of_day)
type_of_day.cat.categories
type_of_day.cat.ordered
```


::: {.rmd-details}
You'll notice that, in this instance, `pd.cut` did not return a `Series` object. It can, but `pd.cut`'s return type will depend on the inputs you feed in. In this case, it returned a [`Categorical`](http://pandas-docs.github.io/pandas-docs-travis/reference/api/pandas.Categorical.html#pandas.Categorical), which is not the same thing as a `Series`. In the code above, I had to convert it back before accessing the `cat` attribute.
:::


<!--chapter:end:07-categorical_data.Rmd-->


# Data Frames

Placeholder


## Data Frames in R
## Data Frames in Python
## Row Names and Indexes
## Getting Versus Setting

<!--chapter:end:08-data_frames.Rmd-->


# (PART) Common Tasks and Patterns {-} 

Placeholder


## General Input Considerations
## Reading in Text Files with R
## Reading in Text Files with Python
## Output

<!--chapter:end:09-io.Rmd-->


# Using Third-Party Code

Placeholder


## Installing Packages In R 
## Installing Packages In Python 
## Loading Packages In R 
## Loading Packages In Python 
### `import`ing Examples

<!--chapter:end:10-third_party_code.Rmd-->


# Control Flow

Placeholder


## Conditional Logic 
## Loops
## A Longer Example
### Description of Accept-Reject Sampling
### A Specific Example

<!--chapter:end:11-control_flow.Rmd-->


# Reshaping and Combining Data Sets

Placeholder


## Ordering and Sorting Data
## Stacking Data Sets and Placing Them Shoulder to Shoulder
## Merging or Joining Data Sets
## Long Versus Wide Data
### Long Versus Wide in R
### Long Versus Wide in Python

<!--chapter:end:12-reshaping.Rmd-->


# Visualization

Placeholder


## Base R Plotting
## Plotting with `ggplot2`
## Plotting with Matplotlib

<!--chapter:end:13-visualization.Rmd-->

# Working With Text Data

TODO

- regular expressions


<!--chapter:end:14-text_data.Rmd-->

# Dates and Times

TODO


<!--chapter:end:15-dates_and_times.Rmd-->

# Running Scripts from the Command Line

TODO


<!--chapter:end:16-CLI.Rmd-->


# (PART) Programming Styles {-} 

Placeholder


## OOP In Python
### Overview
### A First Example
### Adding Inheritance
### Adding in Composition
## OOP In R
### S3 objects: The Big Picture
### Using S3 objects
### Creating S3 objects
### S4 objects: The Big Picture
### Using S4 objects
### Creating S4 objects
### Reference Classes: The Big Picture
### Creating Reference Classes
### Creating R6 Classes
## Exercises

<!--chapter:end:17-oop.Rmd-->


# Functional Programming

Placeholder


## Functions as Function Inputs in R
### `sapply()` and `vapply()`
### `lapply()`
### `apply()`
### `tapply()`
### `mapply()`
### `Reduce()` and `do.call()`
## Another Example in R
## Functions as Function Inputs in Base Python
### `map()`
### `filter()`
## Functions as Function Inputs in Numpy
## Functional Methods in Pandas
## Functions as Function Inputs (miscellany)
## Functions as Function Outputs in R
## Functions as Function Outputs in Python

<!--chapter:end:18-FP.Rmd-->

