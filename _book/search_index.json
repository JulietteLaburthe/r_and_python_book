[["categorical-data.html", "Chapter 6 Categorical Data 6.1 factors in R 6.2 Categorical Data in Python", " Chapter 6 Categorical Data While statisticians may describe data as being either categorical or numerical, this classification is different than classifying data by its type in a program. So, strictly speaking, if you have categorical data, you are not obligated to use any particular type to represent it in your script. However, there are types that are specifically designed to be used with categorical data, and so they are especially advantageous to use if you end up with the opportunity. We describe a few of them here in this chapter. 6.1 factors in R Categorical data in R is often stored in a factor variable. factors are more special than vectors of integers because they have a levels attribute, which is comprised of all the possible values that each response could be; they may or may not be ordered, which will also control how they are used in mathematical functions; they might have a contrasts attribute, which will control how they are used in statistical modeling functions. Here is a first example. Say we asked three people what their favorite season was. The data might look something like this. allSeasons &lt;- c(&quot;autumn&quot;, &quot;summer&quot;, &quot;spring&quot;, &quot;winter&quot;) responses &lt;- factor(c(&quot;autumn&quot;, &quot;summer&quot;, &quot;summer&quot;), levels = allSeasons) levels(responses) ## [1] &quot;autumn&quot; &quot;summer&quot; &quot;spring&quot; &quot;winter&quot; is.factor(responses) ## [1] TRUE is.ordered(responses) ## [1] FALSE #contrasts(responses) # controls how factor is used in different functions factors always have levels, which is the collection of all possible unique values each observation can take. You should be careful if you are not specifying them directly. What happens when you use the default option and replace the second assignment in the above code with responses &lt;- factor(c(\"autumn\", \"summer\", \"summer\"))? The documentation of factor() will tell you that, by default, factor() will just take the unique values found in the data. In this case, nobody prefers winter or spring, and so neither will show up in levels(responses). This may or may not be what you want. factors can be ordered or unordered. Ordered factors are for ordinal data. Ordinal data is a particular type of categorical data that recognizes the categories have a natural order (e.g. low/ medium/high and not red/green/blue). As another example, say we asked ten people how much they liked statistical computing, and they could only respond “love it,” “it’s okay” or “hate it.” The data might look something like this. ordFeelOptions &lt;- c(&quot;hate it&quot;, &quot;it&#39;s okay&quot;, &quot;love it&quot;) responses &lt;- factor(c(&quot;love it&quot;, &quot;it&#39;s okay&quot;, &quot;love it&quot;, &quot;love it&quot;, &quot;it&#39;s okay&quot;, &quot;love it&quot;, &quot;love it&quot;, &quot;love it&quot;, &quot;it&#39;s okay&quot;, &quot;it&#39;s okay&quot;), levels = ordFeelOptions, ordered = TRUE) levels(responses) ## [1] &quot;hate it&quot; &quot;it&#39;s okay&quot; &quot;love it&quot; is.factor(responses) ## [1] TRUE is.ordered(responses) ## [1] TRUE # contrasts(responses) When creating ordered factors with factor(), be mindful that the levels= argument is assumed to be ordered when you plug it into factor(). In the above example, if you specified levels = c(\"love it\", \"it's okay\", \"hate it\"), then the factor would assume love it &lt; it's okay &lt; hate it, which may or may not be what you want. Last, factors may or may not have a contrast attribute. You can get or set this with the contrasts() function. This will influence some of the functions you use on your data that estimate statistical models. I will not discuss specifics of contrasts in this text, but the overall motivation is important. In short, the primary reason for using factors is that they are designed to allow control over how you model categorical data. To be more specific, changing attributes of a factor could control the paremeterization of a model you’re estimating. If you’re using a particular function for modeling with categorical data, you need to know how it treats factors. On the other hand, if you’re writing a function that performs modeling of categorical data, you should know how to treat factors. Here are two examples that you might come across in your studies. Consider using factors as inputs to a function that performs linear regression. With linear regression models, if you have categorical inputs, there are many choices for how to write down a model. In each model, the collection of parameters will mean different things. In R, you might pick the model by creating the factor in a specific way. Suppose you are interested in estimating a classification model. In this case, the dependent variable is categorical, not the independent variable. With these types of models, choosing whether or not your factor is ordered is critical. These options would estimate completely different models, so choose wisely! The mathematical details of these examples is outside of the scope of this text. If you have not learned about dummy variables in a regression course, or if you have not considered the difference between multinomial logistic regression and ordinal logistic regression, or if you have but you’re just a little rusty, that is totally fine. I only mention these as examples for how the factor type can trigger special behavior. In addition to creating one with factor(), there are two other common ways that you can end up with factors: creating factors from numerical data, and when reading in an external data file, one of the columns is coerced to a factor. Here is an example of (1). We can take non-categorical data, and cut() it into something categorical. stockReturns &lt;- rnorm(10) # not categorical here typeOfDay &lt;- cut(stockReturns, breaks = c(-Inf, 0, Inf)) typeOfDay ## [1] (-Inf,0] (0, Inf] (-Inf,0] (-Inf,0] (0, Inf] (-Inf,0] (0, Inf] (-Inf,0] ## [9] (0, Inf] (0, Inf] ## Levels: (-Inf,0] (0, Inf] levels(typeOfDay) ## [1] &quot;(-Inf,0]&quot; &quot;(0, Inf]&quot; is.factor(typeOfDay) ## [1] TRUE is.ordered(typeOfDay) ## [1] FALSE Finally, be mindful of how different functions read in external data sets. When reading in an external file, if a particular function comes across a column that has characters in it, it will need to decide whether to store that column as a character vector, or as a factor. For example, read.csv() and read.table() have a stringsAsFactors= argument that you should be mindful of. 6.2 Categorical Data in Python Categorical data can be handled with the pandas library, which takes a lot of inspiration from R. We’ve talked about Series objects before in section 2.4, and here we will use them again. All we have to do to make a Series object categorical is to change its dtype. The dtype we provide will control the categories (like levels in R), and whether it’s ordered or not. import pandas as pd from pandas.api.types import CategoricalDtype cat_type = CategoricalDtype(categories=[&quot;autumn&quot;, &quot;summer&quot;, &quot;spring&quot;, &quot;winter&quot;], ordered=False) responses = pd.Series([&quot;autumn&quot;, &quot;summer&quot;, &quot;summer&quot;], dtype = cat_type) responses ## 0 autumn ## 1 summer ## 2 summer ## dtype: category ## Categories (4, object): [&#39;autumn&#39;, &#39;summer&#39;, &#39;spring&#39;, &#39;winter&#39;] responses.cat.categories ## Index([&#39;autumn&#39;, &#39;summer&#39;, &#39;spring&#39;, &#39;winter&#39;], dtype=&#39;object&#39;) responses.cat.ordered ## False The pandas library also provides a pd.cut() function, which can return either of these types, or even a regular Numpy array. import numpy as np stock_returns = np.random.normal(size=10) # not categorical here type_of_day = pd.cut(stock_returns, [-np.inf, 0, np.inf], labels = [&#39;bad day&#39;, &#39;good day&#39;]) type_of_day ## [&#39;bad day&#39;, &#39;bad day&#39;, &#39;bad day&#39;, &#39;bad day&#39;, &#39;good day&#39;, &#39;bad day&#39;, &#39;good day&#39;, &#39;bad day&#39;, &#39;bad day&#39;, &#39;good day&#39;] ## Categories (2, object): [&#39;bad day&#39; &lt; &#39;good day&#39;] type(type_of_day) ## &lt;class &#39;pandas.core.arrays.categorical.Categorical&#39;&gt; type_of_day = pd.Series(type_of_day) type(type_of_day) ## &lt;class &#39;pandas.core.series.Series&#39;&gt; type_of_day.cat.categories ## Index([&#39;bad day&#39;, &#39;good day&#39;], dtype=&#39;object&#39;) type_of_day.cat.ordered ## True You’ll notice that, in this instance, pd.cut did not return a Series object. It can, but pd.cut’s return type will depend on the inputs you feed in. In this case, it returned a Categorical, which is not the same thing as a Series. In the code above, I had to convert it back before accessing the cat attribute. "]]
